import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.4aTu-Nia.js";const o=JSON.parse('{"title":"24.两两交换链表中的节点","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/算法/链表/24.两两交换链表中的节点.md","filePath":"docs/02 技术/算法/链表/24.两两交换链表中的节点.md"}'),t={name:"docs/02 技术/算法/链表/24.两两交换链表中的节点.md"},h=n(`<h1 id="_24-两两交换链表中的节点" tabindex="-1">24.两两交换链表中的节点 <a class="header-anchor" href="#_24-两两交换链表中的节点" aria-label="Permalink to &quot;24.两两交换链表中的节点&quot;">​</a></h1><h2 id="一、问题描述" tabindex="-1">一、问题描述 <a class="header-anchor" href="#一、问题描述" aria-label="Permalink to &quot;一、问题描述&quot;">​</a></h2><p>给定一个链表，两两交换链表中的节点，并返回交换后的链表。</p><p><strong>示例:</strong></p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</span></span></code></pre></div><h2 id="二、方案一-迭代法" tabindex="-1">二、方案一：迭代法 <a class="header-anchor" href="#二、方案一-迭代法" aria-label="Permalink to &quot;二、方案一：迭代法&quot;">​</a></h2><h3 id="_1、思路" tabindex="-1">1、思路 <a class="header-anchor" href="#_1、思路" aria-label="Permalink to &quot;1、思路&quot;">​</a></h3><p>使用迭代法来两两交换链表中的节点。</p><ul><li>定义虚拟头结点，这样会方便很多，要不然每次针对头结点特殊处理（没有前一个指针指向头结点的场景）</li><li>通过下面三个步骤完成相邻节点的交换，然后指针向后移动2位，重复上面的过程</li></ul><p><img src="https://muchuang-img.oss-cn-beijing.aliyuncs.com/linknode.png" alt=""></p><h3 id="_2、代码实现" tabindex="-1">2、代码实现 <a class="header-anchor" href="#_2、代码实现" aria-label="Permalink to &quot;2、代码实现&quot;">​</a></h3><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> swapPairs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{Next: head}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.Next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.Next.Next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 保存第一个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		tmp1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.Next</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 保存后置节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		tmp2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.Next.Next.Next</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		/* 第2个节点和第1个节点交换 */</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 步骤一：前置节点指向第2个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		cur.Next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.Next.Next</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 步骤2：第2个节点指向第1个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		cur.Next.Next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tmp1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// 步骤3：第1个节点指向后置节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		tmp1.Next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> tmp2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.Next.Next </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// cur移动两位，准备下一轮交换</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy.Next</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3、复杂度分析" tabindex="-1">3、复杂度分析 <a class="header-anchor" href="#_3、复杂度分析" aria-label="Permalink to &quot;3、复杂度分析&quot;">​</a></h3><ul><li>时间复杂度：O(n)，其中 n 是链表的长度。我们需要遍历整个链表一次。</li><li>空间复杂度：O(1)，不需要额外的空间。</li></ul><h2 id="三、方案二-递归法" tabindex="-1">三、方案二：递归法 <a class="header-anchor" href="#三、方案二-递归法" aria-label="Permalink to &quot;三、方案二：递归法&quot;">​</a></h2><h3 id="_1、思路-1" tabindex="-1">1、思路 <a class="header-anchor" href="#_1、思路-1" aria-label="Permalink to &quot;1、思路&quot;">​</a></h3><p>使用递归法来两两交换链表中的节点。递归法的基本思路是：</p><ul><li>设置当前节点的下一个节点的指针指向当前节点。</li><li>递归地交换剩余的链表。</li><li>将当前节点的指针指向新的头节点。</li></ul><h3 id="_2、代码实现-1" tabindex="-1">2、代码实现 <a class="header-anchor" href="#_2、代码实现-1" aria-label="Permalink to &quot;2、代码实现&quot;">​</a></h3><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> swapPairs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">head</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head.Next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 创建一个节点指针类型保存头结点下一个节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newHead </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head.Next</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 更改头结点，并将头结点的next指针指向这个更改过的list</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    head.Next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> swapPairs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newHead.Next)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将新的头结点的next指针指向老的头节点</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    newHead.Next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> head</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newHead</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3、复杂度分析-1" tabindex="-1">3、复杂度分析 <a class="header-anchor" href="#_3、复杂度分析-1" aria-label="Permalink to &quot;3、复杂度分析&quot;">​</a></h3><ul><li>时间复杂度：O(n)，其中 n 是链表的长度。我们需要遍历整个链表一次。</li><li>空间复杂度：O(n)，递归调用栈的空间。</li></ul><h2 id="四、总结" tabindex="-1">四、总结 <a class="header-anchor" href="#四、总结" aria-label="Permalink to &quot;四、总结&quot;">​</a></h2><table><thead><tr><th>方案</th><th>时间复杂度</th><th>空间复杂度</th></tr></thead><tbody><tr><td>迭代法</td><td>O(n)</td><td>O(1)</td></tr><tr><td>递归法</td><td>O(n)</td><td>O(n)</td></tr></tbody></table><p>迭代法在空间复杂度上更优，而递归法在代码结构上更简洁。选择哪种方法取决于具体的使用场景和个人偏好。</p>`,25),l=[h];function p(e,k,r,d,E,g){return a(),i("div",null,l)}const y=s(t,[["render",p]]);export{o as __pageData,y as default};
