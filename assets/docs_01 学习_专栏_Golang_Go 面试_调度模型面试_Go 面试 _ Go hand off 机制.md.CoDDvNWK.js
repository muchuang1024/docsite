import{_ as o,c as a,o as t,a4 as e}from"./chunks/framework.4aTu-Nia.js";const l=JSON.parse('{"title":"一、什么是 hand off 机制","description":"","frontmatter":{},"headers":[],"relativePath":"docs/01 学习/专栏/Golang/Go 面试/调度模型面试/Go 面试 | Go hand off 机制.md","filePath":"docs/01 学习/专栏/Golang/Go 面试/调度模型面试/Go 面试 | Go hand off 机制.md"}'),n={name:"docs/01 学习/专栏/Golang/Go 面试/调度模型面试/Go 面试 | Go hand off 机制.md"},f=e('<h1 id="一、什么是-hand-off-机制" tabindex="-1">一、什么是 hand off 机制 <a class="header-anchor" href="#一、什么是-hand-off-机制" aria-label="Permalink to &quot;一、什么是 hand off 机制&quot;">​</a></h1><p>Go 语言的 hand off 机制 和 work steaing 机制一样，也是一种用于调度协程（Goroutines）的策略，有助于充分利用多核 CPU，提高并发性能，减少线程空转，从而使 Go 程序更高效地运行</p><p>hand off 机制也称为 P 分离机制，核心思想是当线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行</p><h1 id="二、分离流程" tabindex="-1">二、分离流程 <a class="header-anchor" href="#二、分离流程" aria-label="Permalink to &quot;二、分离流程&quot;">​</a></h1><p>当 M 执行的 G 发生阻塞操作或者发生了系统调用，M 就会阻塞，如果当前绑定的 P 还有要执行的 G, Go runtime 会把这个 P 从 M 摘除，M 进入阻塞（对应下图中的 M1），P 分离给其它空闲 M 调度（对应下图中的 M2）</p><p>当 M 系统调用（或阻塞）结束时，这个 G 会尝试获取一个空闲的 P 执行，并放入到这个 P 的本地队列，如果获取不到 P，那么这个 G 加入到全局 G 里，这个 M 会加入到空闲线程列表中，重新可以进入调度循环</p><p><img src="https://static.xiaobot.net/file/2023-11-12/263968/b55b48ff726b0f34f4e01421ac28af4d.png!post" alt=""></p>',7),_=[f];function d(s,r,c,h,i,p){return t(),a("div",null,_)}const P=o(n,[["render",d]]);export{l as __pageData,P as default};
