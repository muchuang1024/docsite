import{_ as s,c as a,o as i,a4 as n}from"./chunks/framework.4aTu-Nia.js";const g=JSON.parse('{"title":"1.两数之和","description":"","frontmatter":{},"headers":[],"relativePath":"docs/03 博客/算法/哈希表/1.两数之和.md","filePath":"docs/03 博客/算法/哈希表/1.两数之和.md"}'),t={name:"docs/03 博客/算法/哈希表/1.两数之和.md"},e=n(`<h1 id="_1-两数之和" tabindex="-1">1.两数之和 <a class="header-anchor" href="#_1-两数之和" aria-label="Permalink to &quot;1.两数之和&quot;">​</a></h1><h2 id="一、问题描述" tabindex="-1">一、问题描述 <a class="header-anchor" href="#一、问题描述" aria-label="Permalink to &quot;一、问题描述&quot;">​</a></h2><p>给定一个整数数组 <code>nums</code> 和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p><strong>示例</strong>：</p><div class="language-plaintext vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">plaintext</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>给定 nums = [2, 7, 11, 15], target = 9</span></span>
<span class="line"><span>因为 nums[0] + nums[1] = 2 + 7 = 9</span></span>
<span class="line"><span>所以返回 [0, 1]</span></span></code></pre></div><h2 id="二、方案一-暴力法" tabindex="-1">二、方案一：暴力法 <a class="header-anchor" href="#二、方案一-暴力法" aria-label="Permalink to &quot;二、方案一：暴力法&quot;">​</a></h2><h3 id="_1、思路" tabindex="-1">1、思路 <a class="header-anchor" href="#_1、思路" aria-label="Permalink to &quot;1、思路&quot;">​</a></h3><p>暴力法是最直观的方法。通过遍历数组中的每一个数 <code>x</code>，并查找是否存在一个值与 <code>target - x</code> 相等的目标元素。</p><h3 id="_2、代码实现" tabindex="-1">2、代码实现 <a class="header-anchor" href="#_2、代码实现" aria-label="Permalink to &quot;2、代码实现&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>func twoSum(nums []int, target int) []int {</span></span>
<span class="line"><span>    for i := 0; i &lt; len(nums); i++ {</span></span>
<span class="line"><span>        for j := i + 1; j &lt; len(nums); j++ {</span></span>
<span class="line"><span>            if nums[j] == target - nums[i] {</span></span>
<span class="line"><span>                return []int{i, j}</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    return nil</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="_3、复杂度分析" tabindex="-1">3、复杂度分析 <a class="header-anchor" href="#_3、复杂度分析" aria-label="Permalink to &quot;3、复杂度分析&quot;">​</a></h3><ul><li>时间复杂度：O(n^2)，其中 n 是数组中的元素数量。最坏的情况下可能需要对每个元素进行 n-1 次比较。</li><li>空间复杂度：O(1)，因为只使用了常数级别的额外空间</li></ul><h2 id="三、方案二-哈希表法" tabindex="-1">三、方案二：哈希表法 <a class="header-anchor" href="#三、方案二-哈希表法" aria-label="Permalink to &quot;三、方案二：哈希表法&quot;">​</a></h2><h3 id="_1、思路-1" tabindex="-1">1、思路 <a class="header-anchor" href="#_1、思路-1" aria-label="Permalink to &quot;1、思路&quot;">​</a></h3><p>在方案二的基础上，我们可以进行一些优化。我们可以在遍历数组的同时建立哈希表，这样只需要遍历一次数组。对于每个元素 <code>x</code>，我们首先检查 <code>target - x</code> 是否在哈希表中，如果不在，我们将它加入哈希表。</p><h3 id="_2、代码实现-1" tabindex="-1">2、代码实现 <a class="header-anchor" href="#_2、代码实现-1" aria-label="Permalink to &quot;2、代码实现&quot;">​</a></h3><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">func</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> twoSum</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    numMap </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i, num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> range</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        complement </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> num</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j, ok </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numMap[complement]; ok {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{j, i}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        numMap[num] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nil</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="_3、复杂度分析-1" tabindex="-1">3、复杂度分析 <a class="header-anchor" href="#_3、复杂度分析-1" aria-label="Permalink to &quot;3、复杂度分析&quot;">​</a></h3><ul><li>时间复杂度：O(n)，其中 n 是数组中的元素数量。我们只遍历了一次数组。</li><li>空间复杂度：O(n)，我们需要一个哈希表来存储数值到索引的映射。</li></ul><h2 id="四、总结" tabindex="-1">四、总结 <a class="header-anchor" href="#四、总结" aria-label="Permalink to &quot;四、总结&quot;">​</a></h2><table><thead><tr><th>方案</th><th>时间复杂度</th><th>空间复杂度</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>暴力法</td><td>O(n^2)</td><td>O(1)</td><td>实现简单</td><td>效率低</td></tr><tr><td>哈希表法</td><td>O(n)</td><td>O(n)</td><td>效率高，只需遍历一次</td><td>需要额外空间</td></tr><tr><td>推荐使用一遍哈希表法，因为它在时间和空间效率上都较为优秀。</td><td></td><td></td><td></td><td></td></tr></tbody></table>`,22),l=[e];function h(p,k,d,r,o,c){return i(),a("div",null,l)}const u=s(t,[["render",h]]);export{g as __pageData,u as default};
