import{_ as s,c as a,o as n,a4 as e}from"./chunks/framework.4aTu-Nia.js";const m=JSON.parse('{"title":"一、基本概念","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/Golang/Go 源码/Go 源码 | Go slice 的底层实现原理.md","filePath":"docs/02 技术/Golang/Go 源码/Go 源码 | Go slice 的底层实现原理.md"}'),p={name:"docs/02 技术/Golang/Go 源码/Go 源码 | Go slice 的底层实现原理.md"},l=e(`<h1 id="一、基本概念" tabindex="-1">一、基本概念 <a class="header-anchor" href="#一、基本概念" aria-label="Permalink to &quot;一、基本概念&quot;">​</a></h1><p>切片是基于数组实现的，它的底层是数组，可以理解为对 底层数组的抽象，源码包中 src/runtime/slice.go 定义了 slice 的数据结构</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>type slice struct {</span></span>
<span class="line"><span>  array unsafe.Pointer</span></span>
<span class="line"><span>  len  int</span></span>
<span class="line"><span>  cap int</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>slice 占用 24 个字节</p><p>array: 指向底层数组的指针，占用 8 个字节</p><p>len: 切片的长度，占用 8 个字节</p><p>cap: 切片的容量，cap 总是大于等于 len 的，占用 8 个字节</p><h1 id="二、使用方式" tabindex="-1">二、使用方式 <a class="header-anchor" href="#二、使用方式" aria-label="Permalink to &quot;二、使用方式&quot;">​</a></h1><p>slice 有 4 种初始化方式</p><p>初始化方式 1：直接声明</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var slice1 []int</span></span></code></pre></div><p>初始化方式 2：使用字面量</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>slice2 := []int{1, 2, 3, 4}</span></span></code></pre></div><p>初始化方式 3：使用 make 创建 slice</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>slice3 := make([]int, 3, 5)</span></span></code></pre></div><p>初始化方式 4: 从切片或数组“截取”</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>slcie4 := arr[1:3]</span></span></code></pre></div><h1 id="三、底层实现" tabindex="-1">三、底层实现 <a class="header-anchor" href="#三、底层实现" aria-label="Permalink to &quot;三、底层实现&quot;">​</a></h1><p>通过一个简单程序，看下 slice 初始化调用的底层函数</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>package main</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>import &quot;fmt&quot;</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>func main() {</span></span>
<span class="line"><span>  slice := make([]int, 0)</span></span>
<span class="line"><span>  slice = append(slice, 1)</span></span>
<span class="line"><span>  fmt.Println(slice, len(slice), cap(slice))</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>通过 go tool compile -S test.go | grep CALL 得到汇编代码</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>0x0042 00066 (test.go:6)        CALL    runtime.makeslice(SB)</span></span>
<span class="line"><span>0x006d 00109 (test.go:7)        CALL    runtime.growslice(SB)</span></span>
<span class="line"><span>0x00a4 00164 (test.go:8)        CALL    runtime.convTslice(SB)</span></span>
<span class="line"><span>0x00c0 00192 (test.go:8)        CALL    runtime.convT64(SB)</span></span>
<span class="line"><span>0x00d8 00216 (test.go:8)        CALL    runtime.convT64(SB)</span></span>
<span class="line"><span>0x0166 00358 ($GOROOT/src/fmt/print.go:274)     CALL    fmt.Fprintln(SB)</span></span>
<span class="line"><span>0x0180 00384 (test.go:5)        CALL    runtime.morestack_noctxt(SB)</span></span>
<span class="line"><span>0x0079 00121 (&lt;autogenerated&gt;:1)        CALL    runtime.efaceeq(SB)</span></span>
<span class="line"><span>0x00a0 00160 (&lt;autogenerated&gt;:1)        CALL    runtime.morestack_noctxt(SB)</span></span></code></pre></div><p>初始化 slice 调用的是 runtime.makeslice，makeslice 函数的工作主要就是计算 slice 所需内存大小，然后调用 mallocgc 进行内存的分配，所需内存大小 = 切片中元素大小 * 切片的容量</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>func makeslice(et *_type, len, cap int) unsafe.Pointer {</span></span>
<span class="line"><span>  mem, overflow := math.MulUintptr(et.size, uintptr(cap))</span></span>
<span class="line"><span>  if overflow || mem &gt; maxAlloc || len &lt; 0 || len &gt; cap {</span></span>
<span class="line"><span>    mem, overflow := math.MulUintptr(et.size, uintptr(len))</span></span>
<span class="line"><span>    if overflow || mem &gt; maxAlloc || len &lt; 0 {</span></span>
<span class="line"><span>      panicmakeslicelen()</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    panicmakeslicecap()</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>​</span></span>
<span class="line"><span>  return mallocgc(mem, et, true)</span></span>
<span class="line"><span>}</span></span></code></pre></div>`,24),t=[l];function i(c,o,r,d,h,u){return n(),a("div",null,t)}const v=s(p,[["render",i]]);export{m as __pageData,v as default};
