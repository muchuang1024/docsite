import{_ as t,c as d,o,a4 as _}from"./chunks/framework.4aTu-Nia.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/01 学习/课程/Golang/Go 面试/内存管理面试/Go 面试 | Go 有哪些方式安全读写共享变量.md","filePath":"docs/01 学习/课程/Golang/Go 面试/内存管理面试/Go 面试 | Go 有哪些方式安全读写共享变量.md"}'),e={name:"docs/01 学习/课程/Golang/Go 面试/内存管理面试/Go 面试 | Go 有哪些方式安全读写共享变量.md"},a=_("<p>Go 语言中有不同方法用于安全读写共享变量的对比，整理成表格形式如下</p><table><thead><tr><th>方法</th><th>描述</th><th>使用场景</th></tr></thead><tbody><tr><td>sync.Mutex</td><td>互斥锁，确保同一时间只有一个 goroutine 可以访问共享资源。</td><td>适用于需要保护的资源或代码块访问量较大的情况。</td></tr><tr><td>sync.RWMutex</td><td>读写互斥锁，允许多个读操作，但写操作会阻塞其他读写操作。</td><td>适用于读多写少的场景，可以提高读操作的并发性。</td></tr><tr><td>sync/atomic</td><td>提供原子操作，用于管理简单数据类型的并发访问。</td><td>适用于简单数据类型（如整数、指针）的并发更新。</td></tr><tr><td>Channel</td><td>提供数据传递的方式，避免直接访问共享内存。</td><td>适用于 goroutine 间的通信和数据传递。</td></tr><tr><td>sync.Once</td><td>保证某个操作只执行一次。</td><td>适用于只需要执行一次的初始化操作，例如单例模式的初始化。</td></tr></tbody></table>",2),r=[a];function n(c,s,i,h,l,G){return o(),d("div",null,r)}const u=t(e,[["render",n]]);export{m as __pageData,u as default};
