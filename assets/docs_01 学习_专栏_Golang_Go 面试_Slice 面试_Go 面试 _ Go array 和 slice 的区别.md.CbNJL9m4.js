import{_ as t,c as d,o as a,a4 as e}from"./chunks/framework.4aTu-Nia.js";const v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/01 学习/专栏/Golang/Go 面试/Slice 面试/Go 面试 | Go array 和 slice 的区别.md","filePath":"docs/01 学习/专栏/Golang/Go 面试/Slice 面试/Go 面试 | Go array 和 slice 的区别.md"}'),s={name:"docs/01 学习/专栏/Golang/Go 面试/Slice 面试/Go 面试 | Go array 和 slice 的区别.md"},r=e('<p><strong>1、array</strong></p><p>有固定大小的就是数组</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var a [10]int</span></span></code></pre></div><p><strong>2、slice</strong></p><p>无固定大小的就是切片</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>var a []int</span></span></code></pre></div><p><strong>3、两者区别</strong></p><table><thead><tr><th>特性</th><th>数组 (array)</th><th>切片 (slice)</th></tr></thead><tbody><tr><td>大小</td><td>固定大小，定义时指定。</td><td>动态大小，可以改变。</td></tr><tr><td>类型</td><td>值类型。复制数组会复制其全部元素。</td><td>引用类型。复制切片仅复制指向底层数组的引用。</td></tr><tr><td>声明</td><td>var a [n]Type</td><td>var s []Type 或 s := make([]Type, len, cap)</td></tr><tr><td>零值</td><td>元素类型的零值构成的数组。</td><td>nil</td></tr><tr><td>内部结构</td><td>单纯的连续内存块。</td><td>包含指针、长度和容量的描述符指向底层数组。</td></tr><tr><td>内存分配</td><td>栈分配（如果是局部变量）。</td><td>堆分配（动态增长时）。</td></tr><tr><td>性能</td><td>大型数组可能导致较大的复制开销。</td><td>复制效率高，因为仅复制切片描述符。</td></tr><tr><td>用法</td><td>适用于已知固定数量元素的场景。</td><td>适用于需要动态大小的场景，如动态数组。</td></tr><tr><td>容量操作</td><td>不可改变。</td><td>可以使用内置的<code>append</code>函数动态增加大小。</td></tr><tr><td>底层数据修改</td><td>直接修改数组元素。</td><td>通过切片间接修改底层数组的元素。</td></tr><tr><td>时间复杂度</td><td>计算数组长度 O(n)。</td><td>计算数组长度 O(1)。</td></tr></tbody></table>',8),o=[r];function n(p,c,i,l,_,h){return a(),d("div",null,o)}const u=t(s,[["render",n]]);export{v as __pageData,u as default};
