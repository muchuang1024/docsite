import{_ as o,c as _,o as e,a4 as t}from"./chunks/framework.4aTu-Nia.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/01 学习/专栏/Golang/Go 面试/内存管理面试/Go 面试 | Go GC 如何调优.md","filePath":"docs/01 学习/专栏/Golang/Go 面试/内存管理面试/Go 面试 | Go GC 如何调优.md"}'),G={name:"docs/01 学习/专栏/Golang/Go 面试/内存管理面试/Go 面试 | Go GC 如何调优.md"},p=t("<p>1、增大 GOGC 的值</p><p><code>GOGC</code>环境变量控制着垃圾回收的触发时机。默认值是 100，意味着每当堆内存增长到上次 GC 后的两倍时，就会触发 GC。将这个值设置得更高可以减少 GC 的频率，但会增加内存使用量。相反，设置得更低可以减少内存使用，但会增加 GC 的频率。</p><p>2、减少内存分配</p><p>优化代码以减少内存分配，比如使用池化技术（如<code>sync.Pool</code>）或全局变量，重用对象，或优化数据结构以减少不必要的内存占用。</p><p>3、避免大量的临时对象</p><p>如果函数调用创建了大量的临时对象，增加了 GC 的回收对象数，从而增加 GC 压力，尽可能地重用对象可以减轻这种压力。</p><p>4、控制协程数</p><p>Go 的 GC 是并发的，这意味着它会在后台线程中运行，与应用程序的 goroutines 并行。但是，如果应用程序有太多的 goroutines 在运行，它们可能会争夺 CPU 资源，导致 GC 无法及时完成。合理地平衡并发性和工作量对于维护良好的 GC 性能至关重要。</p><p>5、提前分配内存</p><p>slice 提前分配足够的内存来降低扩容带来的拷贝</p>",10),c=[p];function s(a,n,r,d,C,i){return e(),_("div",null,c)}const f=o(G,[["render",s]]);export{m as __pageData,f as default};
