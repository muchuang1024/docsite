import{_ as a,c as t,o as e,a4 as s}from"./chunks/framework.4aTu-Nia.js";const h=JSON.parse('{"title":"一、正常模式(非公平锁)","description":"","frontmatter":{},"headers":[],"relativePath":"docs/01 学习/专栏/Golang/Go 面试/Mutex 面试/Go 面试 | Go 互斥锁正常模式和饥饿模式的区别.md","filePath":"docs/01 学习/专栏/Golang/Go 面试/Mutex 面试/Go 面试 | Go 互斥锁正常模式和饥饿模式的区别.md"}'),n={name:"docs/01 学习/专栏/Golang/Go 面试/Mutex 面试/Go 面试 | Go 互斥锁正常模式和饥饿模式的区别.md"},o=s(`<p>在 Go 一共可以分为两种抢锁的模式，一种是<strong>正常模式</strong>，另外一种是<strong>饥饿模式</strong>。</p><h1 id="一、正常模式-非公平锁" tabindex="-1">一、正常模式(非公平锁) <a class="header-anchor" href="#一、正常模式-非公平锁" aria-label="Permalink to &quot;一、正常模式(非公平锁)&quot;">​</a></h1><p>在刚开始的时候，是处于正常模式（Barging），也就是，当一个 G1 持有着一个锁的时候，G2 会自旋的去尝试获取这个锁</p><p>当 G2 <strong>自旋超过 4 次</strong>还没有能获取到锁的时候，这个 G2 就会被加入到获取锁的等待队列里面，并阻塞等待唤醒</p><p>正常模式下，所有等待锁的 goroutine 按照 FIFO(先进先出)顺序等待。</p><p>唤醒的 goroutine 不会直接拥有锁，而是会和新请求锁的 goroutine 竞争锁。新请求锁的 goroutine 具有优势：它正在 CPU 上执行，而且可能有好几个，所以刚刚唤醒的 goroutine 有很大可能在锁竞争中失败，长时间获取不到锁，就会切换到饥饿模式</p><h1 id="二、饥饿模式-公平锁" tabindex="-1">二、饥饿模式(公平锁) <a class="header-anchor" href="#二、饥饿模式-公平锁" aria-label="Permalink to &quot;二、饥饿模式(公平锁)&quot;">​</a></h1><p>当一个 goroutine 等待锁时间超过 1 毫秒时，它可能会遇到饥饿问题。 在版本 1.9 中，这种场景下 Go Mutex 切换到饥饿模式（handoff），解决饥饿问题。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>starving = runtime_nanotime()-waitStartTime &gt; 1e6</span></span></code></pre></div><p>饥饿模式下，直接把锁交给等待队列中排在第一位的 goroutine(队头)，同时饥饿模式下，新进来的 goroutine 不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部,这样很好的解决了老的 goroutine 一直抢不到锁的场景。</p><p>那么也不可能说永远的保持一个饥饿的状态，总归会有吃饱的时候，也就是总有那么一刻 Mutex 会回归到正常模式，那么回归正常模式必须具备的条件有以下几种：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>1. G的执行时间小于1ms</span></span>
<span class="line"><span>2. 等待队列已经全部清空了</span></span></code></pre></div><p>当满足上述两个条件的任意一个的时候，Mutex 会切换回正常模式，而 Go 的抢锁的过程，就是在这个正常模式和饥饿模式中来回切换进行的。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)</span></span>
<span class="line"><span>if !starving || old&gt;&gt;mutexWaiterShift == 1 {</span></span>
<span class="line"><span>	delta -= mutexStarving</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>atomic.AddInt32(&amp;m.state, delta)</span></span></code></pre></div><h1 id="三、总结" tabindex="-1">三、总结 <a class="header-anchor" href="#三、总结" aria-label="Permalink to &quot;三、总结&quot;">​</a></h1><p>对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，其实是性能和公平的 一个平衡模式。</p>`,16),i=[o];function p(l,r,c,d,_,u){return e(),t("div",null,i)}const m=a(n,[["render",p]]);export{h as __pageData,m as default};
