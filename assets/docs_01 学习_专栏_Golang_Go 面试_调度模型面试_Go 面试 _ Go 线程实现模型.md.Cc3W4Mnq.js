import{_ as a,c as i,o as t,a4 as e}from"./chunks/framework.4aTu-Nia.js";const u=JSON.parse('{"title":"一、什么是线程模型","description":"","frontmatter":{},"headers":[],"relativePath":"docs/01 学习/专栏/Golang/Go 面试/调度模型面试/Go 面试 | Go 线程实现模型.md","filePath":"docs/01 学习/专栏/Golang/Go 面试/调度模型面试/Go 面试 | Go 线程实现模型.md"}'),l={name:"docs/01 学习/专栏/Golang/Go 面试/调度模型面试/Go 面试 | Go 线程实现模型.md"},o=e('<h1 id="一、什么是线程模型" tabindex="-1">一、什么是线程模型 <a class="header-anchor" href="#一、什么是线程模型" aria-label="Permalink to &quot;一、什么是线程模型&quot;">​</a></h1><p>线程创建、管理、调度等采用的方式称为线程模型，线程模型一般分为以下三种：<code>内核级线程模型</code>、<code>用户级线程模型</code>、<code>两级线程模型</code>，他们的区别在于用户线程与内核线程之间的对应关系，用户级线程由应用程序管理，而内核级线程由操作系统管理。</p><h1 id="二、三种线程模型" tabindex="-1">二、三种线程模型 <a class="header-anchor" href="#二、三种线程模型" aria-label="Permalink to &quot;二、三种线程模型&quot;">​</a></h1><h2 id="内核级线程模型-1-1" tabindex="-1">内核级线程模型（1：1） <a class="header-anchor" href="#内核级线程模型-1-1" aria-label="Permalink to &quot;内核级线程模型（1：1）&quot;">​</a></h2><p>1 个用户线程对应 1 个内核线程，这种最容易实现，协程的调度都由 CPU 完成了</p><p><img src="https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/ult_klt_1_1.jpg#id=W2JCh&amp;originHeight=918&amp;originWidth=1038&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>优点：</p><ul><li>实现起来最简单</li><li>能够利用多核</li><li>如果进程中的一个线程被阻塞，不会阻塞其他线程，是能够切换同一进程内的其他线程继续执行</li></ul><p>缺点：</p><ul><li>上下文切换成本高，创建、删除和切换都由 CPU 完成（创建一个用户线程，就需要创建一个内核线程，发生一次系统调用）</li></ul><h2 id="用户级线程模型-n-1" tabindex="-1">用户级线程模型（N：1） <a class="header-anchor" href="#用户级线程模型-n-1" aria-label="Permalink to &quot;用户级线程模型（N：1）&quot;">​</a></h2><p>1 个进程中的所有线程对应 1 个内核线程 <img src="https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/ult_klt_n_1.jpg#id=ETmHc&amp;originHeight=938&amp;originWidth=1032&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""> 优点：</p><ul><li>上下文切换成本低，在用户态即可完成协程切换</li></ul><p>缺点：</p><ul><li>无法利用多核</li><li>一旦协程阻塞，造成线程阻塞，本线程的其它协程无法执行</li></ul><h2 id="两级线程模型-m-n" tabindex="-1">两级线程模型（M：N) <a class="header-anchor" href="#两级线程模型-m-n" aria-label="Permalink to &quot;两级线程模型（M：N)&quot;">​</a></h2><p>M 个线程对应 N 个内核线程</p><p><img src="https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/ult_klt_n_m.jpg#id=Usv0V&amp;originHeight=932&amp;originWidth=1012&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>优点：</p><ul><li>能够利用多核</li><li>上下文切换成本低</li><li>如果进程中的一个线程被阻塞，不会阻塞其他线程，会切换同一进程内的其他线程继续执行</li></ul><p>缺点：</p><ul><li>实现起来最复杂</li></ul><h1 id="三、总结" tabindex="-1">三、总结 <a class="header-anchor" href="#三、总结" aria-label="Permalink to &quot;三、总结&quot;">​</a></h1><p>Go 实现的就是两级线程模型（M：N)，准确的说是 GMP 模型，是对两级线程模型的改进实现，使它能够更加灵活地进行线程之间的调度。</p>',24),n=[o];function r(p,s,d,c,h,m){return t(),i("div",null,n)}const g=a(l,[["render",r]]);export{u as __pageData,g as default};
