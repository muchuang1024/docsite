import{_ as t,c as a,o as e,a4 as o}from"./chunks/framework.4aTu-Nia.js";const g=JSON.parse('{"title":"一、线程间通信方式","description":"","frontmatter":{},"headers":[],"relativePath":"docs/02 技术/Golang/Go 面试/并发面试/Go 面试 | Go 常用的并发模型.md","filePath":"docs/02 技术/Golang/Go 面试/并发面试/Go 面试 | Go 常用的并发模型.md"}'),i={name:"docs/02 技术/Golang/Go 面试/并发面试/Go 面试 | Go 常用的并发模型.md"},n=o('<p>并发模型说的是系统中的线程如何协作完成并发任务，不同的并发模型，线程以不同的方式进行<strong>通信</strong>和协作。</p><h1 id="一、线程间通信方式" tabindex="-1">一、线程间通信方式 <a class="header-anchor" href="#一、线程间通信方式" aria-label="Permalink to &quot;一、线程间通信方式&quot;">​</a></h1><p>线程间通信方式有两种：共享内存和消息传递，无论是哪种通信模型，线程或者协程最终都会从内存中获取数据，所以更为准确的说法是直接共享内存、发送消息的方式来同步信息</p><p>下面是一个表格，对比了共享内存和发送消息（如 Go 语言中的 CSP 模型）两种并发模型的不同属性：</p><table><thead><tr><th>特性</th><th>共享内存</th><th>发送消息</th></tr></thead><tbody><tr><td>抽象层级</td><td>低（适用于对性能要求极高或需要细粒度控制的场景）</td><td>高（提供良好的封装和与领域相关的设计）</td></tr><tr><td>耦合</td><td>高（线程间直接操作共享数据）</td><td>低（基于生产者-消费者模型，线程间通过消息传递交互）</td></tr><tr><td>线程竞争</td><td>需要互斥锁来避免</td><td>通过 channel 保证资源同一时间只由一个线程访问</td></tr></tbody></table><p>这个表格简要地说明了两种并发模型在抽象层级、耦合度以及线程竞争处理上的主要区别。在 Go 语言中，CSP 模型通过 channel 来实现线程间的通信，而共享内存模型则需要显式地使用互斥锁来控制对共享资源的访问。</p><p>Go 语言中实现了两种并发模型，一种是共享内存并发模型，另一种则是 CSP 模型。</p><h1 id="二、共享内存并发模型" tabindex="-1">二、共享内存并发模型 <a class="header-anchor" href="#二、共享内存并发模型" aria-label="Permalink to &quot;二、共享内存并发模型&quot;">​</a></h1><p>通过直接共享内存 + 锁的方式同步信息，传统多线程并发</p><p><img src="https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/image-20220514161804822.png#id=iVBNH&amp;originHeight=298&amp;originWidth=613&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h1 id="三、csp-并发模型" tabindex="-1">三、CSP 并发模型 <a class="header-anchor" href="#三、csp-并发模型" aria-label="Permalink to &quot;三、CSP 并发模型&quot;">​</a></h1><p>通过发送消息的方式来同步信息，Go 语言推荐使用的<em>通信顺序进程</em>（communicating sequential processes）并发模型，通过 goroutine 和 channel 来实现</p><p>1、<code>goroutine</code> 是 Go 语言中并发的执行单位，可以理解为”线程“</p><p>2、<code>channel</code>是 Go 语言中各个并发结构体(<code>goroutine</code>)之前的通信机制。 通俗的讲，就是各个<code>goroutine</code>之间通信的”管道“，类似于 Linux 中的管道</p><p><img src="https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/image-20220514161841437.png#id=WAvrC&amp;originHeight=277&amp;originWidth=607&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p>',15),d=[n];function r(p,s,c,l,h,_){return e(),a("div",null,d)}const u=t(i,[["render",r]]);export{g as __pageData,u as default};
