import{_ as a,c as t,o as e,a4 as o}from"./chunks/framework.4aTu-Nia.js";const g=JSON.parse('{"title":"一、什么是 GC","description":"","frontmatter":{},"headers":[],"relativePath":"docs/01 学习/专栏/Golang/Go 面试/内存管理面试/Go 面试 | Go GC 实现原理.md","filePath":"docs/01 学习/专栏/Golang/Go 面试/内存管理面试/Go 面试 | Go GC 实现原理.md"}'),p={name:"docs/01 学习/专栏/Golang/Go 面试/内存管理面试/Go 面试 | Go GC 实现原理.md"},r=o('<h1 id="一、什么是-gc" tabindex="-1">一、什么是 GC <a class="header-anchor" href="#一、什么是-gc" aria-label="Permalink to &quot;一、什么是 GC&quot;">​</a></h1><p>垃圾回收也称为 GC（Garbage Collection），是一种自动内存管理机制</p><p>现代高级编程语言管理内存的方式分为两种：自动和手动，像 C、C++ 等编程语言使用手动管理内存的方式，工程师编写代码过程中需要主动申请或者释放内存；而 PHP、Java 和 Go 等语言使用自动的内存管理系统，有内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的 GC。</p><p>在应用程序中会使用到两种内存，分别为堆（Heap）和栈（Stack），GC 负责回收堆内存，而不负责回收栈中的内存</p><p>栈是线程的专用内存，专门为了函数执行而准备的，存储着函数中的局部变量以及调用栈，函数执行完后，编译器可以将栈上分配的内存可以直接释放，不需要通过 GC 来回收。</p><p>堆是程序共享的内存，需要 GC 进行回收在堆上分配的内存。</p><p>垃圾回收器的执行过程被划分为两个半独立的组件：</p><p>赋值器（Mutator）：这一名称本质上是在指代用户态的代码。因为对垃圾回收器而言，用户态的代码仅仅只是在修改对象之间的引用关系，也就是在对象图（对象之间引用关系的一个有向图）上进行操作。</p><p>回收器（Collector）：负责执行垃圾回收的代码。</p><h1 id="二、主流-gc-算法" tabindex="-1">二、主流 GC 算法 <a class="header-anchor" href="#二、主流-gc-算法" aria-label="Permalink to &quot;二、主流 GC 算法&quot;">​</a></h1><p>目前比较常见的垃圾回收算法有三种：</p><table><thead><tr><th>垃圾回收策略</th><th>代表语言</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>引用计数</td><td>Python、PHP、Swift</td><td>对象回收快，不会出现内存耗尽或达到某个阈值时才回收。</td><td>不能很好的处理循环引用，维护引用计数有损耗。</td></tr><tr><td>分代收集</td><td>Java</td><td>回收性能好</td><td>算法复杂</td></tr><tr><td>标记-清除</td><td>Golang（三色标记法）</td><td>解决了引用计数的缺点。</td><td>需要 STW，暂停程序运行。</td></tr></tbody></table><h1 id="三、go-gc-算法" tabindex="-1">三、Go GC 算法 <a class="header-anchor" href="#三、go-gc-算法" aria-label="Permalink to &quot;三、Go GC 算法&quot;">​</a></h1><h2 id="一-gc-算法概念" tabindex="-1">一）GC 算法概念 <a class="header-anchor" href="#一-gc-算法概念" aria-label="Permalink to &quot;一）GC 算法概念&quot;">​</a></h2><p>Go 语言采用的是标记清除算法，并在此基础上使用了三色标记法和混合写屏障技术，G C 过程和其他用户 goroutine 可并发运行，但需要一定时间的 STW</p><p><img src="https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/image-20220503232512072.png#id=un8ui&amp;originHeight=334&amp;originWidth=554&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=#id=DOoS0&amp;originHeight=334&amp;originWidth=554&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><p>三色标记法只是为了叙述方便而抽象出来的一种说法，实际上的对象是没有三色之分的。这里的三色，对应了垃圾回收过程中对象的三种状态：</p><p>白色：白色通常表示节点未被访问或未处理。在开始算法执行时，所有节点都被初始化为白色。</p><p>灰色：灰色表示节点已经被访问，但尚未完成对其子节点的访问。</p><p>黑色：黑色表示节点已经被访问并且已经完成了对其子节点的访问。</p><p><img src="https://raw.githubusercontent.com/muchuang1024/imgcdn/master/image-20231202220826085.png" alt=""></p><h3 id="_1、root-对象" tabindex="-1">1、root 对象 <a class="header-anchor" href="#_1、root-对象" aria-label="Permalink to &quot;1、root 对象&quot;">​</a></h3><p>根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：</p><p>全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。</p><p>执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上指向堆内存的指针。</p><p>寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。</p><h3 id="_2、插入写屏障" tabindex="-1">2、插入写屏障 <a class="header-anchor" href="#_2、插入写屏障" aria-label="Permalink to &quot;2、插入写屏障&quot;">​</a></h3><p>对象被引用时触发的机制（只在堆内存中生效）：赋值器将插入行为通知给并发执行的回收器，进而产生可能需要额外（重新）扫描的对象 ，被引用的对象标记为灰色</p><p>缺点：结束时需要 STW 来重新扫描栈，标记栈上引用的白色对象的存活</p><h3 id="_3、删除写屏障" tabindex="-1">3、删除写屏障 <a class="header-anchor" href="#_3、删除写屏障" aria-label="Permalink to &quot;3、删除写屏障&quot;">​</a></h3><p>对象被删除时触发的机制（只在堆内存中生效）：赋值器将删除行为通知给并发执行的回收器，被删除的对象，如果自身为灰色或者白色，那么标记为灰色</p><p>缺点：一个对象的引用被删除后，即使没有其他存活的对象引用它，出于性能考虑，它仍然会活到下一轮（如果本轮回收会产生很大冗余扫描成本），降低了回收精度</p><h3 id="_4、混合写屏障" tabindex="-1">4、混合写屏障 <a class="header-anchor" href="#_4、混合写屏障" aria-label="Permalink to &quot;4、混合写屏障&quot;">​</a></h3><p>GC 没有混合写屏障前，一直是插入写屏障；混合写屏障是插入写屏障 + 删除写屏障，写屏障只应用在堆上应用，栈上不启用（栈上启用成本很高）</p><p>1、GC 开始将栈上的对象全部扫描并标记为黑色。</p><p>2、GC 期间，任何在栈上创建的新对象，均为黑色。</p><p>3、被删除的对象标记为灰色。</p><p>4、被添加的对象标记为灰色。</p><h2 id="二-gc-流程" tabindex="-1">二）GC 流程 <a class="header-anchor" href="#二-gc-流程" aria-label="Permalink to &quot;二）GC 流程&quot;">​</a></h2><p>一次完整的垃圾回收会分为四个阶段，分别是标记准备、标记开始、标记终止、清理：</p><p>1、标记准备（Mark Setup）：打开写屏障（Write Barrier），需 STW（stop the world)</p><p>2、标记开始（Marking）：使用三色标记法并发标记 ，与用户程序并发执行</p><p>3、标记终止（Mark Termination）：对触发写屏障的对象进行重新扫描标记，关闭写屏障（Write Barrier），需 STW （stop the world)</p><p>4、清理（Sweeping）：将需要回收的内存归还到堆中，将过多的内存归还给操作系统，与用户程序并发执行</p><p><img src="https://cdn.jsdelivr.net/gh/caijinlin/imgcdn/image-20220504185906969.png#id=kExOV&amp;originHeight=585&amp;originWidth=785&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=#id=C2cNY&amp;originHeight=585&amp;originWidth=785&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;title=" alt=""></p><h2 id="三-gc-触发时机" tabindex="-1">三）GC 触发时机 <a class="header-anchor" href="#三-gc-触发时机" aria-label="Permalink to &quot;三）GC 触发时机&quot;">​</a></h2><p>1、<strong>主动触发</strong></p><p>调用 runtime.GC() 方法，触发 GC</p><p>2、<strong>被动触发：</strong></p><p>定时触发，该触发条件由 <code>runtime.forcegcperiod</code> 变量控制，默认为 2 分 钟。当超过两分钟没有产生任何 GC 时，触发 GC</p><p>根据内存分配阈值触发，该触发条件由环境变量 GOGC 控制，默认值为 100（100%），当前堆内存占用是上次 GC 结束后占用内存的 2 倍时，触发 GC</p><h2 id="四-gc-算法演进" tabindex="-1">四）GC 算法演进 <a class="header-anchor" href="#四-gc-算法演进" aria-label="Permalink to &quot;四）GC 算法演进&quot;">​</a></h2><p>Go 1：mark and sweep 操作都需要 STW</p><p>Go 1.3：分离了 mark 和 sweep 操作，mark 过程需要 STW，mark 完成后让 sweep 任务和普通协程任务一样并行，停顿时间在约几百 ms</p><p>Go 1.5：引入三色并发标记法、插入写屏障，不需要每次都扫描整个内存空间，可以减少 stop the world 的时间，停顿时间在 100ms 以内</p><p>Go 1.6：使用 bitmap 来记录回收内存的位置，大幅优化垃圾回收器自身消耗的内存，停顿时间在 10ms 以内</p><p>Go 1.7：停顿时间控制在 2ms 以内</p><p>Go 1.8：混合写屏障（插入写屏障和删除写屏障），停顿时间在 0.5ms 左右</p><p>Go 1.9：彻底移除了栈的重扫描过程</p><p>Go 1.12：整合了两个阶段的 Mark Termination</p><p>Go 1.13：着手解决向操作系统归还内存的，提出了新的 Scavenger</p><p>Go 1.14：替代了仅存活了一个版本的 scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题，并引入了异步抢占，解决了由于密集循环导致的 STW 时间过长的问题</p>',62),i=[r];function n(d,h,l,s,m,c){return e(),t("div",null,i)}const _=a(p,[["render",n]]);export{g as __pageData,_ as default};
