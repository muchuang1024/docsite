import{_ as s,c as t,o as e,a4 as a}from"./chunks/framework.4aTu-Nia.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/01 学习/课程/Golang/Go 面试/基础面试/Go 面试 | Go 内置函数 make 和 new 的区别.md","filePath":"docs/01 学习/课程/Golang/Go 面试/基础面试/Go 面试 | Go 内置函数 make 和 new 的区别.md"}'),i={name:"docs/01 学习/课程/Golang/Go 面试/基础面试/Go 面试 | Go 内置函数 make 和 new 的区别.md"},d=a('<p>在 Go 语言中，<code>make</code>和<code>new</code>是两个用于分配内存的内置函数，但它们的用途和行为有着明显的区别：</p><p>1、<strong>new</strong></p><p><code>new(T)</code>为任意类型分配零值内存，并返回其地址，即一个<code>*T</code>类型的值。它仅分配内存，不初始化内存，所分配的内存被初始化为类型的零值。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">num </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> new</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 分配内存，*num 初始化为 0</span></span></code></pre></div><p>使用 new 基础类型后可以直接使用，使用 new 切片等引用类型后需要额外的初始化</p><p>2、<strong>make</strong></p><p><code>make</code>仅用于切片（slice）、映射（map）和通道（channel）这三种引用类型的内存分配和初始化。<code>make(T, args)</code>返回初始化后的（非零）值，而不是指针。对于切片，<code>make</code>还可以接受长度和容量参数。</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> make</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个长度为 10 的切片，元素初始化为 0</span></span></code></pre></div><p>3、<strong>两者的区别</strong></p><table><thead><tr><th>特性</th><th>new</th><th>make</th></tr></thead><tbody><tr><td>返回类型</td><td>指针（<code>*T</code>）</td><td>引用类型的实例（如<code>slice</code>、<code>map</code>、<code>channel</code>）</td></tr><tr><td>用途</td><td>为类型分配零值内存</td><td>分配并初始化切片、映射、通道</td></tr><tr><td>初始化</td><td>分配的内存被初始化为零值</td><td>分配的内存被初始化为非零值</td></tr><tr><td>适用类型</td><td>任何类型</td><td>仅限切片、映射、通道</td></tr></tbody></table><p>在实际使用中，选择<code>new</code>还是<code>make</code>通常取决于你需要的是指针还是已初始化的引用类型。</p>',11),n=[d];function o(p,h,c,l,k,r){return e(),t("div",null,n)}const E=s(i,[["render",o]]);export{g as __pageData,E as default};
